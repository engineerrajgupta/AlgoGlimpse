<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlgoGlimps</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        nav {
            background-color: #1e293b; /* Dark slate for navbar */
            padding: 1rem 2rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        nav h1 {
            color: #ffffff;
            font-size: 1.75rem; /* text-2xl */
            font-weight: 700; /* font-bold */
        }
        .nav-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .nav-section label {
            color: #cbd5e1; /* Light gray text */
            font-weight: 600;
            font-size: 0.95rem;
        }
        .nav-section select, .nav-section button {
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: none;
        }
        .nav-section select {
            background-color: #334155; /* Darker slate */
            color: #ffffff;
            appearance: none; /* Remove default arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='white'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'%3E%3C/path%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.2em;
        }
        .nav-section select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.4); /* Focus ring */
        }
        .nav-section button {
            background-color: #4f46e5; /* Indigo */
            color: #ffffff;
        }
        .nav-section button:hover {
            background-color: #4338ca; /* Darker indigo */
            transform: translateY(-1px);
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 90%;
            width: 1000px; /* Increased max-width for better visualization */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background-color: #e2e8f0; /* Lighter blue-gray for canvas */
            border-radius: 0.75rem;
            border: 1px solid #cbd5e1;
            display: block;
            width: 100%;
            max-width: 900px; /* Match container width */
            height: 500px; /* Increased height for graph visualization */
            margin-bottom: 1.5rem;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            width: 100%;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .btn-primary {
            background-color: #4f46e5; /* Indigo */
            color: #ffffff;
        }
        .btn-primary:hover {
            background-color: #4338ca; /* Darker indigo */
            transform: translateY(-2px);
        }
        .btn-secondary {
            background-color: #6b7280; /* Gray */
            color: #ffffff;
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Darker gray */
            transform: translateY(-2px);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #4a5568; /* Darker gray text */
        }
        input[type="range"] {
            width: 150px;
            -webkit-appearance: none;
            height: 8px;
            background: #cbd5e1;
            outline: none;
            border-radius: 4px;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .info-box {
            background-color: #f8fafc; /* Lighter background for info */
            border-radius: 0.75rem;
            padding: 1.5rem;
            width: 100%;
            max-width: 900px;
            border: 1px solid #e2e8f0;
            color: #334155; /* Darker text */
        }
        .info-box h3 {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 0.75rem;
            color: #1e293b; /* Even darker text */
        }
        .info-box p {
            margin-bottom: 0.5rem;
            line-height: 1.5;
        }
        .info-box pre {
            background-color: #1e293b; /* Dark background for code */
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Fira Code', monospace; /* Monospace font for code */
            font-size: 0.9rem;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .input-group label {
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            color: #4a5568; /* Darker gray text */
        }
        .input-group select, .input-group input[type="number"] {
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid #cbd5e1;
            background-color: #ffffff;
            color: #334155;
            font-size: 0.875rem;
        }
        /* Grid-specific styles */
        #gridCanvas {
            background-color: #ffffff; /* White background for grid */
            border-radius: 0.75rem;
            border: 1px solid #cbd5e1;
            display: block;
            width: 100%;
            max-width: 900px;
            height: 500px;
            margin-bottom: 1.5rem;
        }
        .grid-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            width: 100%;
        }

        /* Custom Modal Styling (for alerts) */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 0.75rem;
            border: 1px solid #888;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
        }
        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #1e293b;
        }
        .modal-content p {
            margin-bottom: 1.5rem;
            color: #334155;
        }
        .modal-content button {
            background-color: #4f46e5;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
        }
        .modal-content button:hover {
            background-color: #4338ca;
        }

        /* Matrix Table Styling */
        .matrix-container {
            width: 100%;
            max-width: 900px;
            margin-top: 1.5rem;
            overflow-x: auto;
            background-color: #f8fafc;
            border-radius: 0.75rem;
            border: 1px solid #e2e8f0;
            padding: 1rem;
        }
        .matrix-container h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #1e293b;
            text-align: center;
        }
        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Fira Code', monospace;
            font-size: 0.85rem;
        }
        .matrix-table th, .matrix-table td {
            border: 1px solid #cbd5e1;
            padding: 0.5rem;
            text-align: center;
            min-width: 40px; /* Ensure cells are wide enough */
        }
        .matrix-table th {
            background-color: #e2e8f0;
            color: #334155;
            font-weight: 600;
        }
        .matrix-table td {
            background-color: #ffffff;
            color: #334155;
        }
        .matrix-table td.highlight-cell {
            background-color: #f59e0b; /* Amber for current cell */
            font-weight: bold;
            color: #ffffff;
        }
        .matrix-table td.updated-cell {
            background-color: #10b981; /* Green for updated cell */
            font-weight: bold;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <nav>
        <h1>AlgoGlimps</h1>
        <div class="nav-section">
            <label for="modeSelect">Mode:</label>
            <select id="modeSelect">
                <option value="graph">Graph</option>
                <option value="grid">Grid</option>
            </select>
        </div>
        <div class="nav-section">
            <label for="algorithmSelect">Algorithm:</label>
            <select id="algorithmSelect">
                <option value="bfs">Breadth-First Search (BFS)</option>
                <option value="dfs">Depth-First Search (DFS)</option>
                <option value="dijkstra">Dijkstra's Algorithm</option>
                <option value="floyd-warshall">Floyd-Warshall Algorithm</option>
                <option value="mst">Minimum Spanning Tree</option>
            </select>
        </div>
        <div class="nav-section">
            <button id="compareButton">Compare (Coming Soon)</button>
        </div>
    </nav>

    <div class="main-content">
        <div id="graphContainer" class="container">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4" id="graphAlgorithmTitle">Breadth-First Search (BFS)</h2>
            <canvas id="visualizationCanvas"></canvas>

            <div class="controls">
                <div class="input-group" id="graphInteractionModeGroup">
                    <label for="graphInteractionMode">Interaction Mode:</label>
                    <select id="graphInteractionMode" class="form-select">
                        <option value="select">Select/Move Node</option>
                        <option value="add-node">Add Node</option>
                        <option value="remove-node">Remove Node</option>
                        <option value="add-edge">Add Edge</option>
                        <option value="remove-edge">Remove Edge</option>
                    </select>
                </div>
                <div class="input-group" id="newEdgeWeightGroup" style="display: none;">
                    <label for="newEdgeWeight">Edge Weight:</label>
                    <input type="number" id="newEdgeWeight" value="1" min="1" class="form-input w-20">
                </div>
                <div class="input-group" id="startNodeGroup">
                    <label for="startNodeSelect">Start Node:</label>
                    <select id="startNodeSelect" class="form-select"></select>
                </div>
                <div class="input-group" id="targetNodeGroup" style="display: none;">
                    <label for="targetNodeSelect">Target Node:</label>
                    <select id="targetNodeSelect" class="form-select"></select>
                </div>
                <button id="startButton" class="btn btn-primary">Start</button>
                <button id="resetButton" class="btn btn-secondary">Reset</button>
                <div class="slider-container">
                    <label for="speedSlider" class="text-sm font-medium">Speed:</label>
                    <input type="range" id="speedSlider" min="10" max="1000" value="200">
                    <span id="speedValue" class="text-sm">200ms</span>
                </div>
            </div>

            <div class="info-box" id="graphAlgorithmInfoBox">
                <h3>Breadth-First Search (BFS) Algorithm</h3>
                <p>
                    Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'), and explores all of the neighbor nodes at the present depth before moving on to the nodes at the next depth level.
                </p>
                <p>
                    BFS is commonly used to find the shortest path in an unweighted graph.
                </p>
                <h3>Pseudocode:</h3>
                <pre>
function BFS(graph, startNode):
    create a queue Q
    create a set of visited nodes V
    add startNode to Q
    add startNode to V

    while Q is not empty:
        currentNode = Q.dequeue()
        process currentNode (e.g., print it)

        for each neighbor of currentNode:
            if neighbor is not in V:
                add neighbor to V
                add neighbor to Q
                </pre>
            </div>

            <div id="matrixContainer" class="matrix-container hidden">
                <h4>Distance Matrix</h4>
                <div id="distanceMatrixTable"></div>
                <!-- Path Matrix can be added here later -->
            </div>
        </div>

        <div id="gridContainer" class="container hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4" id="gridAlgorithmTitle">Grid Visualization</h2>
            <canvas id="gridCanvas"></canvas>
            <div class="grid-controls">
                <button id="generateGridButton" class="btn btn-primary">Generate Grid</button>
                <button id="clearGridButton" class="btn btn-secondary">Clear Grid</button>
                <div class="slider-container">
                    <label for="gridSpeedSlider" class="text-sm font-medium">Speed:</label>
                    <input type="range" id="gridSpeedSlider" min="10" max="1000" value="200">
                    <span id="gridSpeedValue" class="text-sm">200ms</span>
                </div>
            </div>
            <div class="info-box" id="gridAlgorithmInfoBox">
                <h3>Grid Algorithms (Coming Soon)</h3>
                <p>
                    This section will feature algorithms that operate on a grid, such as pathfinding algorithms (e.g., A*, Dijkstra on a grid) and maze generation algorithms.
                </p>
                <p>
                    You will be able to define start/end points, add walls, and watch the algorithms find paths or generate mazes.
                </p>
            </div>
        </div>
    </div>

    <!-- Custom Modal for Alerts -->
    <div id="customModal" class="modal">
        <div class="modal-content">
            <h3 id="modalTitle"></h3>
            <p id="modalMessage"></p>
            <button id="modalCloseButton">OK</button>
        </div>
    </div>

    <script>
        // Global state variables
        let currentMode = 'graph'; // 'graph' or 'grid'
        let currentAlgorithm = 'bfs'; // 'bfs', 'dfs', 'dijkstra', 'floyd-warshall', 'mst'
        let animationSpeed = 200; // Milliseconds

        // DOM Elements
        const modeSelect = document.getElementById('modeSelect');
        const algorithmSelect = document.getElementById('algorithmSelect');
        const compareButton = document.getElementById('compareButton');

        const graphContainer = document.getElementById('graphContainer');
        const gridContainer = document.getElementById('gridContainer');

        const graphAlgorithmTitle = document.getElementById('graphAlgorithmTitle');
        const graphAlgorithmInfoBox = document.getElementById('graphAlgorithmInfoBox');
        const gridAlgorithmTitle = document.getElementById('gridAlgorithmTitle');
        const gridAlgorithmInfoBox = document.getElementById('gridAlgorithmInfoBox');


        // Graph visualization elements (specific to graph mode)
        const canvas = document.getElementById('visualizationCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const speedSlider = document.getElementById('speedSlider');
        const speedValueSpan = document.getElementById('speedValue');
        const startNodeSelect = document.getElementById('startNodeSelect');
        const targetNodeSelect = document.getElementById('targetNodeSelect');
        const startNodeGroup = document.getElementById('startNodeGroup');
        const targetNodeGroup = document.getElementById('targetNodeGroup');

        // Graph Customization Elements
        const graphInteractionModeSelect = document.getElementById('graphInteractionMode');
        const newEdgeWeightInput = document.getElementById('newEdgeWeight');
        const newEdgeWeightGroup = document.getElementById('newEdgeWeightGroup');

        // Custom Modal Elements
        const customModal = document.getElementById('customModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseButton = document.getElementById('modalCloseButton');

        // Matrix Visualization Elements
        const matrixContainer = document.getElementById('matrixContainer');
        const distanceMatrixTableDiv = document.getElementById('distanceMatrixTable');

        // Grid Visualization Elements
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const generateGridButton = document.getElementById('generateGridButton');
        const clearGridButton = document.getElementById('clearGridButton');
        const gridSpeedSlider = document.getElementById('gridSpeedSlider');
        const gridSpeedValueSpan = document.getElementById('gridSpeedValue');

        // Graph definition (nodes and edges) - NOW DYNAMICALLY MODIFIABLE
        let graph = {
            'A': [{ node: 'B', weight: 4 }, { node: 'C', weight: 2 }],
            'B': [{ node: 'A', weight: 4 }, { node: 'D', weight: 5 }, { node: 'E', weight: 10 }],
            'C': [{ node: 'A', weight: 2 }, { node: 'F', weight: 3 }],
            'D': [{ node: 'B', weight: 5 }],
            'E': [{ node: 'B', weight: 10 }, { node: 'F', weight: 1 }],
            'F': [{ node: 'C', weight: 3 }, { node: 'E', weight: 1 }, { node: 'G', weight: 8 }],
            'G': [{ node: 'F', weight: 8 }]
        };

        // Node positions for drawing (fixed for now for a clear layout) - NOW DYNAMICALLY MODIFIABLE
        let nodePositions = {
            'A': { x: 150, y: 100 },
            'B': { x: 300, y: 50 },
            'C': { x: 300, y: 150 },
            'D': { x: 450, y: 50 },
            'E': { x: 450, y: 250 },
            'F': { x: 600, y: 150 },
            'G': { x: 750, y: 150 }
        };

        const nodeRadius = 25;
        let nodesArray = Object.keys(graph); // Array of node names for matrix indexing
        let numNodes = nodesArray.length;
        let nextNodeId = 'H'; // For adding new nodes, start from 'H'

        // State variables for graph algorithm visualization
        let visitedNodes = new Set();
        let queueNodes = []; // For BFS
        let stackNodes = []; // For DFS
        let currentNode = null;
        let visitedOrder = []; // To store the order of visited nodes
        let isAlgorithmRunning = false; // Generic flag for any algorithm running

        // Dijkstra specific state
        let distances = {}; // Stores shortest distance from source
        let previousNodes = {}; // Stores predecessor for path reconstruction
        let finalizedNodes = new Set(); // Nodes whose shortest path is found
        let pathNodes = []; // Nodes in the final shortest path

        // Floyd-Warshall specific state
        let floydDistMatrix = []; // Current distance matrix for visualization
        let floydPathMatrix = []; // Path reconstruction matrix (optional for visualization)
        let currentK = -1, currentI = -1, currentJ = -1; // Indices for highlighting in matrix

        // MST specific state
        let mstEdges = new Set(); // Edges that are part of the MST
        let mstTotalWeight = 0;

        // Grid specific state
        const GRID_ROWS = 20;
        const GRID_COLS = 30;
        let cellSize = 0; // Will be calculated dynamically
        let grid = []; // 2D array representing the grid
        let startGridNode = null;
        let endGridNode = null;
        let gridWalls = new Set(); // Stores "row-col" strings for wall positions
        let gridVisited = new Set(); // For grid pathfinding visualization
        let gridPath = []; // For grid path visualization

        // Graph Interaction State
        let currentGraphInteractionMode = 'select'; // 'select', 'add-node', 'remove-node', 'add-edge', 'remove-edge'
        let draggedNode = null; // Node currently being dragged
        let startEdgeNode = null; // First node clicked when adding an edge
        let mouseX = 0, mouseY = 0; // Current mouse position for drawing temporary edge

        // --- Custom Modal Function ---
        function showModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            customModal.style.display = 'flex'; // Show the modal
        }

        modalCloseButton.addEventListener('click', () => {
            customModal.style.display = 'none'; // Hide the modal
        });

        // --- Priority Queue Implementation (Min-Heap) ---
        class MinPriorityQueue {
            constructor() {
                this.values = [];
            }

            enqueue(value, priority) {
                this.values.push({ value, priority });
                this.sort();
            }

            dequeue() {
                return this.values.shift();
            }

            sort() {
                this.values.sort((a, b) => a.priority - b.priority);
            }

            isEmpty() {
                return this.values.length === 0;
            }
        }

        // --- Core Functions for UI and State Management ---

        // Function to update the UI based on current mode and algorithm
        function updateUI() {
            // Show/hide containers based on mode
            if (currentMode === 'graph') {
                graphContainer.classList.remove('hidden');
                gridContainer.classList.add('hidden');
                
                // Show/hide graph-specific controls
                document.querySelector('#graphContainer .controls').classList.remove('hidden');
                document.getElementById('graphInteractionModeGroup').style.display = 'flex'; // Always show interaction mode

                // Show/hide algorithm-specific dropdowns
                if (currentAlgorithm === 'bfs' || currentAlgorithm === 'dfs' || currentAlgorithm === 'dijkstra' || currentAlgorithm === 'mst') {
                    startNodeGroup.style.display = 'flex';
                } else {
                    startNodeGroup.style.display = 'none';
                }

                if (currentAlgorithm === 'dijkstra') {
                    targetNodeGroup.style.display = 'flex';
                } else {
                    targetNodeGroup.style.display = 'none';
                }

                if (currentAlgorithm === 'floyd-warshall') {
                    matrixContainer.classList.remove('hidden');
                } else {
                    matrixContainer.classList.add('hidden');
                }

                // Show/hide edge weight input based on interaction mode
                if (currentGraphInteractionMode === 'add-edge') {
                    newEdgeWeightGroup.style.display = 'flex';
                } else {
                    newEdgeWeightGroup.style.display = 'none';
                }

                // Disable algorithm-specific controls if in an interaction mode other than 'select'
                const algorithmControlsDisabled = currentGraphInteractionMode !== 'select';
                startButton.disabled = algorithmControlsDisabled;
                resetButton.disabled = algorithmControlsDisabled;
                speedSlider.disabled = algorithmControlsDisabled;
                startNodeSelect.disabled = algorithmControlsDisabled;
                targetNodeSelect.disabled = algorithmControlsDisabled;
                algorithmSelect.disabled = algorithmControlsDisabled;

            } else if (currentMode === 'grid') {
                graphContainer.classList.add('hidden');
                gridContainer.classList.remove('hidden');
                
                // Show/hide grid-specific controls
                document.querySelector('#gridContainer .grid-controls').classList.remove('hidden');
                document.querySelector('#graphContainer .controls').classList.add('hidden'); // Ensure graph controls are hidden
                matrixContainer.classList.add('hidden'); // Hide matrix for grid mode
            }

            // Update algorithm title and info box based on mode
            if (currentMode === 'graph') {
                switch (currentAlgorithm) {
                    case 'bfs':
                        graphAlgorithmTitle.textContent = 'Breadth-First Search (BFS)';
                        graphAlgorithmInfoBox.innerHTML = `
                            <h3>Breadth-First Search (BFS) Algorithm</h3>
                            <p>BFS is an algorithm for traversing or searching tree or graph data structures. It explores all of the neighbor nodes at the present depth before moving on to the nodes at the next depth level.</p>
                            <p>BFS is commonly used to find the shortest path in an unweighted graph.</p>
                            <h3>Pseudocode:</h3>
                            <pre>
function BFS(graph, startNode):
    create a queue Q
    create a set of visited nodes V
    add startNode to Q
    add startNode to V

    while Q is not empty:
        currentNode = Q.dequeue()
        process currentNode (e.g., print it)

        for each neighbor of currentNode:
            if neighbor is not in V:
                add neighbor to V
                add neighbor to Q
                            </pre>
                        `;
                        break;
                    case 'dfs':
                        graphAlgorithmTitle.textContent = 'Depth-First Search (DFS)';
                        graphAlgorithmInfoBox.innerHTML = `
                            <h3>Depth-First Search (DFS) Algorithm</h3>
                            <p>DFS is an algorithm for traversing or searching tree or graph data structures. It explores as far as possible along each branch before backtracking.</p>
                            <p>DFS can be used to find connected components, cycles, and topological sorting.</p>
                            <h3>Pseudocode:</h3>
                            <pre>
function DFS(graph, startNode):
    create a stack S
    create a set of visited nodes V
    push startNode to S
    add startNode to V

    while S is not empty:
        currentNode = S.pop()
        process currentNode

        for each neighbor of currentNode:
            if neighbor is not in V:
                add neighbor to V
                push neighbor to S
                            </pre>
                        `;
                        break;
                    case 'dijkstra':
                        graphAlgorithmTitle.textContent = 'Dijkstra\'s Algorithm';
                        graphAlgorithmInfoBox.innerHTML = `
                            <h3>Dijkstra's Algorithm</h3>
                            <p>Dijkstra's algorithm finds the shortest paths between nodes in a graph, which may have non-negative edge weights.</p>
                            <p>It is widely used in network routing protocols.</p>
                            <h3>Pseudocode:</h3>
                            <pre>
function Dijkstra(graph, startNode):
    distances = map of nodes to infinity
    distances[startNode] = 0
    priorityQueue = add all nodes with their distances

    while priorityQueue is not empty:
        currentNode = node with smallest distance from priorityQueue
        
        for each neighbor of currentNode:
            calculate newDistance = distances[currentNode] + weight(currentNode, neighbor)
            if newDistance < distances[neighbor]:
                distances[neighbor] = newDistance
                update neighbor in priorityQueue
                            </pre>
                        `;
                        break;
                    case 'floyd-warshall':
                        graphAlgorithmTitle.textContent = 'Floyd-Warshall Algorithm';
                        graphAlgorithmInfoBox.innerHTML = `
                            <h3>Floyd-Warshall Algorithm</h3>
                            <p>The Floyd-Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles).</p>
                            <p>It computes shortest paths between all pairs of nodes.</p>
                            <h3>Pseudocode:</h3>
                            <pre>
function FloydWarshall(graph):
    dist = initialize distance matrix with edge weights or infinity
    
    for k from 0 to n-1:
        for i from 0 to n-1:
            for j from 0 to n-1:
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
                            </pre>
                        `;
                        break;
                    case 'mst':
                        graphAlgorithmTitle.textContent = 'Minimum Spanning Tree (Prim\'s Algorithm)';
                        graphAlgorithmInfoBox.innerHTML = `
                            <h3>Minimum Spanning Tree (MST) - Prim's Algorithm</h3>
                            <p>Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. It starts from an arbitrary vertex and grows the MST by adding the cheapest edge from the tree to a vertex not yet in the tree.</p>
                            <h3>Pseudocode (Prim's):</h3>
                            <pre>
function Prim(graph, startNode):
    min_cost = map of nodes to infinity
    parent = map of nodes to null
    min_cost[startNode] = 0
    priorityQueue = add all nodes with their min_cost

    while priorityQueue is not empty:
        currentNode = node with smallest min_cost from priorityQueue
        
        add currentNode to MST
        
        for each neighbor of currentNode:
            if neighbor is not in MST and weight(currentNode, neighbor) < min_cost[neighbor]:
                min_cost[neighbor] = weight(currentNode, neighbor)
                parent[neighbor] = currentNode
                update neighbor in priorityQueue
                            </pre>
                        `;
                        break;
                }
            } else if (currentMode === 'grid') {
                gridAlgorithmTitle.textContent = 'Grid Algorithms';
                gridAlgorithmInfoBox.innerHTML = `
                    <h3>Grid Algorithms (Coming Soon)</h3>
                    <p>
                        This section will feature algorithms that operate on a grid, such as pathfinding algorithms (e.g., A*, Dijkstra on a grid) and maze generation algorithms.
                    </p>
                    <p>
                        You will be able to define start/end points, add walls, and watch the algorithms find paths or generate mazes.
                    </p>
                `;
            }
            resetVisualization(); // Reset visualization when mode or algorithm changes
        }

        // Function to populate the start and target node dropdowns for graph algorithms
        function populateNodeSelects() {
            startNodeSelect.innerHTML = ''; // Clear existing options
            targetNodeSelect.innerHTML = '';
            nodesArray = Object.keys(graph); // Update nodesArray
            numNodes = nodesArray.length; // Update numNodes

            nodesArray.forEach(node => {
                const optionStart = document.createElement('option');
                optionStart.value = node;
                optionStart.textContent = node;
                startNodeSelect.appendChild(optionStart);

                const optionTarget = document.createElement('option');
                optionTarget.value = node;
                optionTarget.textContent = node;
                targetNodeSelect.appendChild(optionTarget);
            });
            // Set default selected nodes
            if (nodesArray.length > 0) {
                startNodeSelect.value = nodesArray[0];
                targetNodeSelect.value = nodesArray[nodesArray.length - 1]; // Default target to last node
            } else {
                startNodeSelect.value = '';
                targetNodeSelect.value = '';
            }
        }

        // --- Graph Visualization Functions ---

        // Function to draw the graph on the canvas
        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            // Draw edges first
            ctx.lineWidth = 2;
            ctx.font = '14px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (const nodeName in graph) {
                const startPos = nodePositions[nodeName];
                if (startPos) {
                    for (const edge of graph[nodeName]) {
                        const neighbor = edge.node;
                        const weight = edge.weight;
                        const endPos = nodePositions[neighbor];
                        if (endPos) {
                            // Determine edge color
                            ctx.strokeStyle = '#94a3b8'; // Default slate gray
                            const edgeKey1 = `${nodeName}-${neighbor}`;
                            const edgeKey2 = `${neighbor}-${nodeName}`;

                            if (currentAlgorithm === 'dijkstra' && pathNodes.includes(nodeName) && pathNodes.includes(neighbor) &&
                                (pathNodes.indexOf(nodeName) === pathNodes.indexOf(neighbor) - 1 || pathNodes.indexOf(neighbor) === pathNodes.indexOf(nodeName) - 1)) {
                                ctx.strokeStyle = '#059669'; // Green for shortest path edges
                            } else if (currentAlgorithm === 'mst' && (mstEdges.has(edgeKey1) || mstEdges.has(edgeKey2))) {
                                ctx.strokeStyle = '#059669'; // Green for MST edges
                            }

                            ctx.beginPath();
                            ctx.moveTo(startPos.x, startPos.y);
                            ctx.lineTo(endPos.x, endPos.y);
                            ctx.stroke();

                            // Draw weight
                            const midX = (startPos.x + endPos.x) / 2;
                            const midY = (startPos.y + endPos.y) / 2;

                            // Calculate offset for text to avoid overlapping line
                            const angle = Math.atan2(endPos.y - startPos.y, endPos.x - startPos.x);
                            const offsetX = 15 * Math.sin(angle);
                            const offsetY = 15 * -Math.cos(angle);

                            ctx.fillStyle = '#1e293b'; // Dark text for weight
                            ctx.fillText(weight, midX + offsetX, midY + offsetY);
                        }
                    }
                }
            }

            // Draw temporary edge line if adding edge
            if (currentGraphInteractionMode === 'add-edge' && startEdgeNode) {
                const startPos = nodePositions[startEdgeNode];
                if (startPos) {
                    ctx.strokeStyle = '#f59e0b'; // Amber for temporary edge
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(startPos.x, startPos.y);
                    ctx.lineTo(mouseX, mouseY);
                    ctx.stroke();
                }
            }

            // Draw nodes and labels
            for (let i = 0; i < nodesArray.length; i++) {
                const node = nodesArray[i];
                const pos = nodePositions[node];

                // Node fill color
                let fillColor = '#60a5fa'; // Blue-500 default
                if (visitedNodes.has(node)) {
                    fillColor = '#10b981'; // Green-500 for visited (BFS/DFS)
                }
                if (queueNodes.includes(node)) {
                    fillColor = '#f59e0b'; // Amber-500 for in BFS queue
                }
                if (stackNodes.includes(node)) {
                    fillColor = '#8b5cf6'; // Purple-500 for in DFS stack
                }
                if (currentAlgorithm === 'dijkstra') {
                    if (finalizedNodes.has(node)) {
                        fillColor = '#10b981'; // Green for finalized (Dijkstra)
                    }
                    if (currentNode === node) {
                        fillColor = '#ef4444'; // Red for current processing (all algos)
                    }
                } else if (currentAlgorithm === 'floyd-warshall') {
                    if (i === currentK) { // Highlight current 'k' node for Floyd-Warshall
                        fillColor = '#ef4444'; // Red
                    }
                } else if (currentAlgorithm === 'mst') {
                    if (visitedNodes.has(node)) { // For MST, visitedNodes means it's part of the growing tree
                        fillColor = '#10b981'; // Green for nodes in MST
                    }
                    if (currentNode === node) {
                        fillColor = '#ef4444'; // Red for current node being processed
                    }
                }
                else { // For BFS/DFS, current node is red
                    if (currentNode === node) {
                        fillColor = '#ef4444'; // Red for current processing
                    }
                }

                // Highlight dragged node
                if (draggedNode === node) {
                    fillColor = '#6366f1'; // Indigo for dragged node
                }
                // Highlight startEdgeNode
                if (startEdgeNode === node) {
                    fillColor = '#f59e0b'; // Amber for start edge node
                }


                ctx.beginPath();
                ctx.arc(pos.x, pos.y, nodeRadius, 0, Math.PI * 2);
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = '#334155'; // Darker border
                ctx.lineWidth = 2;
                ctx.stroke();

                // Node label
                ctx.fillStyle = '#ffffff'; // White text
                ctx.font = 'bold 18px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node, pos.x, pos.y);

                // Display distance for Dijkstra
                if (currentAlgorithm === 'dijkstra' && distances[node] !== Infinity) {
                    ctx.fillStyle = '#1e293b'; // Dark text for distance
                    ctx.font = '12px Inter';
                    ctx.fillText(distances[node], pos.x, pos.y + nodeRadius + 10); // Below the node
                }
            }
        }

        // --- Matrix Visualization Functions (for Floyd-Warshall) ---
        function drawMatrix(matrix, highlightI = -1, highlightJ = -1, updatedI = -1, updatedJ = -1) {
            let tableHTML = '<table class="matrix-table"><thead><tr><th></th>';
            nodesArray.forEach(node => {
                tableHTML += `<th>${node}</th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            for (let i = 0; i < numNodes; i++) {
                tableHTML += `<tr><th>${nodesArray[i]}</th>`;
                for (let j = 0; j < numNodes; j++) {
                    let cellValue = matrix[i][j] === Infinity ? '∞' : matrix[i][j];
                    let cellClass = '';
                    if (i === highlightI && j === highlightJ) {
                        cellClass = 'highlight-cell'; // Currently being considered
                    }
                    if (i === updatedI && j === updatedJ) {
                        cellClass = 'updated-cell'; // Value just updated
                    }
                    tableHTML += `<td class="${cellClass}">${cellValue}</td>`;
                }
                tableHTML += '</tr>';
            }
            tableHTML += '</tbody></table>';
            distanceMatrixTableDiv.innerHTML = tableHTML;
        }

        // --- Grid Visualization Functions ---
        function initializeGrid() {
            grid = Array(GRID_ROWS).fill(0).map(() => Array(GRID_COLS).fill(0)); // 0 for empty, 1 for wall, etc.
            gridWalls = new Set();
            gridVisited = new Set();
            gridPath = [];
            startGridNode = null;
            endGridNode = null;

            // Calculate cell size based on canvas dimensions
            cellSize = Math.min(gridCanvas.width / GRID_COLS, gridCanvas.height / GRID_ROWS);

            drawGrid();
        }

        function drawGrid() {
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const x = c * cellSize;
                    const y = r * cellSize;
                    const cellKey = `${r}-${c}`;

                    gridCtx.strokeStyle = '#cbd5e1'; // Light gray for grid lines
                    gridCtx.strokeRect(x, y, cellSize, cellSize);

                    // Fill cells based on state
                    if (gridWalls.has(cellKey)) {
                        gridCtx.fillStyle = '#4a5568'; // Dark gray for walls
                    } else if (gridPath.includes(cellKey)) {
                        gridCtx.fillStyle = '#6366f1'; // Indigo for path
                    } else if (gridVisited.has(cellKey)) {
                        gridCtx.fillStyle = '#93c5fd'; // Light blue for visited
                    } else {
                        gridCtx.fillStyle = '#ffffff'; // White for empty
                    }
                    gridCtx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2); // Fill with slight padding

                    // Draw start/end nodes
                    if (startGridNode && startGridNode.row === r && startGridNode.col === c) {
                        gridCtx.fillStyle = '#10b981'; // Green for start
                        gridCtx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
                        gridCtx.fillStyle = '#ffffff';
                        gridCtx.font = 'bold 16px Inter';
                        gridCtx.textAlign = 'center';
                        gridCtx.textBaseline = 'middle';
                        gridCtx.fillText('S', x + cellSize / 2, y + cellSize / 2);
                    }
                    if (endGridNode && endGridNode.row === r && endGridNode.col === c) {
                        gridCtx.fillStyle = '#ef4444'; // Red for end
                        gridCtx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
                        gridCtx.fillStyle = '#ffffff';
                        gridCtx.font = 'bold 16px Inter';
                        gridCtx.textAlign = 'center';
                        gridCtx.textBaseline = 'middle';
                        gridCtx.fillText('E', x + cellSize / 2, y + cellSize / 2);
                    }
                }
            }
        }

        // --- Graph Customization Functions ---

        // Helper to find node under mouse
        function getNodeAt(x, y) {
            for (const nodeName in nodePositions) {
                const pos = nodePositions[nodeName];
                const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                if (dist < nodeRadius) {
                    return nodeName;
                }
            }
            return null;
        }

        // Add a new node
        function addNode(x, y) {
            let newNodeName = nextNodeId;
            while (graph[newNodeName]) { // Ensure unique ID
                newNodeName = String.fromCharCode(newNodeName.charCodeAt(0) + 1);
                if (newNodeName.charCodeAt(0) > 'Z'.charCodeAt(0)) {
                    showModal("Error", "Too many nodes! Cannot add more.");
                    return;
                }
            }
            graph[newNodeName] = [];
            nodePositions[newNodeName] = { x, y };
            nextNodeId = String.fromCharCode(newNodeName.charCodeAt(0) + 1); // Increment for next new node
            populateNodeSelects(); // Update dropdowns
            drawGraph();
            showModal("Node Added", `Node '${newNodeName}' added at (${x}, ${y}).`);
        }

        // Remove a node
        function removeNode(nodeName) {
            if (!graph[nodeName]) return;

            // Remove node from graph
            delete graph[nodeName];
            delete nodePositions[nodeName];

            // Remove all edges connected to this node
            for (const otherNode in graph) {
                graph[otherNode] = graph[otherNode].filter(edge => edge.node !== nodeName);
            }
            populateNodeSelects(); // Update dropdowns
            drawGraph();
            showModal("Node Removed", `Node '${nodeName}' and its edges removed.`);
        }

        // Add an edge
        function addEdge(node1, node2, weight) {
            if (node1 === node2) {
                showModal("Error", "Cannot add an edge to the same node.");
                return;
            }
            if (!graph[node1] || !graph[node2]) {
                showModal("Error", "One or both nodes do not exist.");
                return;
            }

            // Check if edge already exists (bidirectional check for simplicity)
            const existingEdge1 = graph[node1].some(edge => edge.node === node2);
            const existingEdge2 = graph[node2].some(edge => edge.node === node1);

            if (existingEdge1 || existingEdge2) {
                showModal("Error", `Edge already exists between ${node1} and ${node2}.`);
                return;
            }

            const parsedWeight = parseInt(weight);
            if (isNaN(parsedWeight) || parsedWeight <= 0) {
                showModal("Invalid Weight", "Please enter a positive number for edge weight.");
                return;
            }

            graph[node1].push({ node: node2, weight: parsedWeight });
            graph[node2].push({ node: node1, weight: parsedWeight }); // Assuming undirected for now
            drawGraph();
            showModal("Edge Added", `Edge added between ${node1} and ${node2} with weight ${parsedWeight}.`);
        }

        // Remove an edge
        function removeEdge(node1, node2) {
            if (!graph[node1] || !graph[node2]) {
                showModal("Error", "One or both nodes do not exist.");
                return;
            }

            const initialLength1 = graph[node1].length;
            const initialLength2 = graph[node2].length;

            graph[node1] = graph[node1].filter(edge => edge.node !== node2);
            graph[node2] = graph[node2].filter(edge => edge.node !== node1); // Assuming undirected for now

            if (graph[node1].length < initialLength1 || graph[node2].length < initialLength2) {
                drawGraph();
                showModal("Edge Removed", `Edge removed between ${node1} and ${node2}.`);
            } else {
                showModal("Error", `No edge found between ${node1} and ${node2}.`);
            }
        }


        // --- Algorithm Implementations ---

        // Breadth-First Search Algorithm with Visualization
        async function bfs(startNode) {
            if (isAlgorithmRunning) return;
            if (!graph[startNode]) { showModal("Error", "Start node does not exist."); return; }
            
            isAlgorithmRunning = true;
            startButton.disabled = true;
            resetButton.disabled = true;
            speedSlider.disabled = true;
            startNodeSelect.disabled = true;
            algorithmSelect.disabled = true;
            modeSelect.disabled = true;
            targetNodeSelect.disabled = true;
            graphInteractionModeSelect.disabled = true; // Disable interaction mode during algorithm

            visitedNodes = new Set();
            queueNodes = [];
            stackNodes = [];
            visitedOrder = [];
            currentNode = null;
            finalizedNodes = new Set();
            pathNodes = [];
            floydDistMatrix = [];
            floydPathMatrix = [];
            currentK = -1; currentI = -1; currentJ = -1;
            mstEdges = new Set();
            mstTotalWeight = 0;

            const queue = [];

            queue.push(startNode);
            visitedNodes.add(startNode);
            queueNodes.push(startNode);

            drawGraph();
            await new Promise(resolve => setTimeout(resolve, animationSpeed));

            while (queue.length > 0) {
                const node = queue.shift();
                currentNode = node;
                queueNodes = queueNodes.filter(n => n !== node);

                visitedOrder.push(node);

                drawGraph();
                await new Promise(resolve => setTimeout(resolve, animationSpeed));

                for (const edge of graph[node]) {
                    const neighbor = edge.node;
                    if (!visitedNodes.has(neighbor)) {
                        visitedNodes.add(neighbor);
                        queue.push(neighbor);
                        queueNodes.push(neighbor);
                        drawGraph();
                        await new Promise(resolve => setTimeout(resolve, animationSpeed));
                    }
                }
            }

            currentNode = null;
            queueNodes = [];
            drawGraph();
            isAlgorithmRunning = false;
            startButton.disabled = false;
            resetButton.disabled = false;
            speedSlider.disabled = false;
            startNodeSelect.disabled = false;
            algorithmSelect.disabled = false;
            modeSelect.disabled = false;
            targetNodeSelect.disabled = false;
            graphInteractionModeSelect.disabled = false; // Re-enable interaction mode
            console.log("BFS Traversal Order:", visitedOrder.join(' -> '));
            showModal("BFS Complete!", `Traversal Order: ${visitedOrder.join(' -> ')}`);
        }

        // Depth-First Search Algorithm with Visualization (Iterative)
        async function dfs(startNode) {
            if (isAlgorithmRunning) return;
            if (!graph[startNode]) { showModal("Error", "Start node does not exist."); return; }

            isAlgorithmRunning = true;
            startButton.disabled = true;
            resetButton.disabled = true;
            speedSlider.disabled = true;
            startNodeSelect.disabled = true;
            algorithmSelect.disabled = true;
            modeSelect.disabled = true;
            targetNodeSelect.disabled = true;
            graphInteractionModeSelect.disabled = true; // Disable interaction mode during algorithm

            visitedNodes = new Set();
            queueNodes = [];
            stackNodes = [];
            visitedOrder = [];
            currentNode = null;
            finalizedNodes = new Set();
            pathNodes = [];
            floydDistMatrix = [];
            floydPathMatrix = [];
            currentK = -1; currentI = -1; currentJ = -1;
            mstEdges = new Set();
            mstTotalWeight = 0;

            const stack = [];

            stack.push(startNode);
            stackNodes.push(startNode);

            drawGraph();
            await new Promise(resolve => setTimeout(resolve, animationSpeed));

            while (stack.length > 0) {
                const node = stack.pop();
                currentNode = node;
                stackNodes = stackNodes.filter(n => n !== node);

                if (!visitedNodes.has(node)) {
                    visitedNodes.add(node);
                    visitedOrder.push(node);

                    drawGraph();
                    await new Promise(resolve => setTimeout(resolve, animationSpeed));

                    const neighbors = graph[node].map(edge => edge.node).sort().reverse();

                    for (const neighbor of neighbors) {
                        if (!visitedNodes.has(neighbor)) {
                            stack.push(neighbor);
                            stackNodes.push(neighbor);
                            drawGraph();
                            await new Promise(resolve => setTimeout(resolve, animationSpeed));
                        }
                    }
                }
            }

            currentNode = null;
            stackNodes = [];
            drawGraph();
            isAlgorithmRunning = false;
            startButton.disabled = false;
            resetButton.disabled = false;
            speedSlider.disabled = false;
            startNodeSelect.disabled = false;
            algorithmSelect.disabled = false;
            modeSelect.disabled = false;
            targetNodeSelect.disabled = false;
            graphInteractionModeSelect.disabled = false; // Re-enable interaction mode
            console.log("DFS Traversal Order:", visitedOrder.join(' -> '));
            showModal("DFS Complete!", `Traversal Order: ${visitedOrder.join(' -> ')}`);
        }

        // Dijkstra's Algorithm with Visualization
        async function dijkstra(startNode, targetNode) {
            if (isAlgorithmRunning) return;
            if (!graph[startNode] || !graph[targetNode]) { showModal("Error", "Start or target node does not exist."); return; }
            if (startNode === targetNode) { showModal("Error", "Start and target nodes cannot be the same."); return; }


            isAlgorithmRunning = true;
            startButton.disabled = true;
            resetButton.disabled = true;
            speedSlider.disabled = true;
            startNodeSelect.disabled = true;
            targetNodeSelect.disabled = true;
            algorithmSelect.disabled = true;
            modeSelect.disabled = true;
            graphInteractionModeSelect.disabled = true; // Disable interaction mode during algorithm

            distances = {};
            previousNodes = {};
            finalizedNodes = new Set();
            pathNodes = [];

            visitedNodes = new Set();
            queueNodes = [];
            stackNodes = [];
            currentNode = null;
            visitedOrder = [];
            floydDistMatrix = [];
            floydPathMatrix = [];
            currentK = -1; currentI = -1; currentJ = -1;
            mstEdges = new Set();
            mstTotalWeight = 0;

            const priorityQueue = new MinPriorityQueue();

            for (const node in graph) {
                distances[node] = Infinity;
                previousNodes[node] = null;
            }
            distances[startNode] = 0;
            priorityQueue.enqueue(startNode, 0);

            drawGraph();
            await new Promise(resolve => setTimeout(resolve, animationSpeed));

            while (!priorityQueue.isEmpty()) {
                const { value: node, priority: currentDistance } = priorityQueue.dequeue();
                currentNode = node;

                if (currentDistance > distances[node]) {
                    continue;
                }

                finalizedNodes.add(node);
                drawGraph();
                await new Promise(resolve => setTimeout(resolve, animationSpeed));

                if (node === targetNode) {
                    let pathCurrent = targetNode;
                    while (pathCurrent) {
                        pathNodes.unshift(pathCurrent);
                        pathCurrent = previousNodes[pathCurrent];
                    }
                    drawGraph();
                    break;
                }

                for (const edge of graph[node]) {
                    const neighbor = edge.node;
                    const weight = edge.weight;
                    const newDistance = distances[node] + weight;

                    if (newDistance < distances[neighbor]) {
                        distances[neighbor] = newDistance;
                        previousNodes[neighbor] = node;
                        priorityQueue.enqueue(neighbor, newDistance);
                        drawGraph();
                        await new Promise(resolve => setTimeout(resolve, animationSpeed));
                    }
                }
            }

            currentNode = null;
            drawGraph();
            isAlgorithmRunning = false;
            startButton.disabled = false;
            resetButton.disabled = false;
            speedSlider.disabled = false;
            startNodeSelect.disabled = false;
            targetNodeSelect.disabled = false;
            algorithmSelect.disabled = false;
            modeSelect.disabled = false;
            graphInteractionModeSelect.disabled = false; // Re-enable interaction mode

            let resultMessage = `Shortest path from ${startNode} to ${targetNode}: `;
            if (distances[targetNode] === Infinity) {
                resultMessage += "No path found.";
            } else {
                resultMessage += `${pathNodes.join(' -> ')} (Total Distance: ${distances[targetNode]})`;
            }
            showModal("Dijkstra's Algorithm Complete!", resultMessage);
            console.log("Dijkstra's Distances:", distances);
            console.log("Dijkstra's Previous Nodes:", previousNodes);
        }

        // Floyd-Warshall Algorithm with Visualization
        async function floydWarshall() {
            if (isAlgorithmRunning) return;
            if (numNodes === 0) { showModal("Error", "Graph is empty. Add nodes to run Floyd-Warshall."); return; }

            isAlgorithmRunning = true;
            startButton.disabled = true;
            resetButton.disabled = true;
            speedSlider.disabled = true;
            startNodeSelect.disabled = true;
            targetNodeSelect.disabled = true;
            algorithmSelect.disabled = true;
            modeSelect.disabled = true;
            graphInteractionModeSelect.disabled = true; // Disable interaction mode during algorithm

            visitedNodes = new Set();
            queueNodes = [];
            stackNodes = [];
            currentNode = null;
            visitedOrder = [];
            distances = {};
            previousNodes = {};
            finalizedNodes = new Set();
            pathNodes = [];
            mstEdges = new Set();
            mstTotalWeight = 0;

            floydDistMatrix = Array(numNodes).fill(0).map(() => Array(numNodes).fill(Infinity));
            floydPathMatrix = Array(numNodes).fill(0).map(() => Array(numNodes).fill(null));

            for (let i = 0; i < numNodes; i++) {
                floydDistMatrix[i][i] = 0;
            }

            for (const nodeName in graph) {
                const i = nodesArray.indexOf(nodeName);
                if (i === -1) continue; // Node might have been removed
                for (const edge of graph[nodeName]) {
                    const j = nodesArray.indexOf(edge.node);
                    if (j === -1) continue; // Neighbor might have been removed
                    floydDistMatrix[i][j] = edge.weight;
                    floydPathMatrix[i][j] = i;
                }
            }

            drawMatrix(floydDistMatrix);
            drawGraph();
            await new Promise(resolve => setTimeout(resolve, animationSpeed * 2));

            for (let k = 0; k < numNodes; k++) {
                currentK = k;
                drawGraph();
                await new Promise(resolve => setTimeout(resolve, animationSpeed * 2));

                for (let i = 0; i < numNodes; i++) {
                    for (let j = 0; j < numNodes; j++) {
                        currentI = i;
                        currentJ = j;
                        drawMatrix(floydDistMatrix, currentI, currentJ);
                        await new Promise(resolve => setTimeout(resolve, animationSpeed));

                        if (floydDistMatrix[i][k] !== Infinity && floydDistMatrix[k][j] !== Infinity) {
                            if (floydDistMatrix[i][j] > floydDistMatrix[i][k] + floydDistMatrix[k][j]) {
                                floydDistMatrix[i][j] = floydDistMatrix[i][k] + floydDistMatrix[k][j];
                                floydPathMatrix[i][j] = floydPathMatrix[k][j];
                                drawMatrix(floloydDistMatrix, -1, -1, i, j);
                                await new Promise(resolve => setTimeout(resolve, animationSpeed * 2));
                            }
                        }
                    }
                }
            }

            currentK = -1; currentI = -1; currentJ = -1;
            drawGraph();
            drawMatrix(floydDistMatrix);
            isAlgorithmRunning = false;
            startButton.disabled = false;
            resetButton.disabled = false;
            speedSlider.disabled = false;
            startNodeSelect.disabled = false;
            targetNodeSelect.disabled = false;
            algorithmSelect.disabled = false;
            modeSelect.disabled = false;
            graphInteractionModeSelect.disabled = false; // Re-enable interaction mode

            console.log("Floyd-Warshall Final Distances:", floydDistMatrix);
            console.log("Floyd-Warshall Path Matrix:", floydPathMatrix);
            showModal("Floyd-Warshall Algorithm Complete!", "All-pairs shortest paths calculated. Check the Distance Matrix below.");
        }

        // Minimum Spanning Tree (Prim's Algorithm) with Visualization
        async function primMST(startNode) {
            if (isAlgorithmRunning) return;
            if (!graph[startNode]) { showModal("Error", "Start node does not exist."); return; }
            if (numNodes === 0) { showModal("Error", "Graph is empty. Add nodes to run MST."); return; }
            if (numNodes === 1) { showModal("MST Complete!", "Graph has only one node. MST is just that node. Total Weight: 0"); return; }


            isAlgorithmRunning = true;
            startButton.disabled = true;
            resetButton.disabled = true;
            speedSlider.disabled = true;
            startNodeSelect.disabled = true;
            algorithmSelect.disabled = true;
            modeSelect.disabled = true;
            targetNodeSelect.disabled = true;
            graphInteractionModeSelect.disabled = true; // Disable interaction mode during algorithm

            mstEdges = new Set();
            mstTotalWeight = 0;

            visitedNodes = new Set();
            queueNodes = [];
            stackNodes = [];
            currentNode = null;
            visitedOrder = [];
            distances = {};
            previousNodes = {};
            finalizedNodes = new Set();
            pathNodes = [];
            floydDistMatrix = [];
            floydPathMatrix = [];
            currentK = -1; currentI = -1; currentJ = -1;

            const minCost = {};
            const parent = {};
            const priorityQueue = new MinPriorityQueue();

            nodesArray.forEach(node => {
                minCost[node] = Infinity;
                parent[node] = null;
            });

            minCost[startNode] = 0;
            priorityQueue.enqueue(startNode, 0);

            drawGraph();
            await new Promise(resolve => setTimeout(resolve, animationSpeed));

            let edgesInMSTCount = 0;
            while (!priorityQueue.isEmpty() && edgesInMSTCount < numNodes - 1) {
                const { value: node, priority: currentMinCost } = priorityQueue.dequeue();

                if (visitedNodes.has(node)) {
                    continue;
                }

                currentNode = node;
                visitedNodes.add(node);

                if (parent[node] !== null) {
                    const edgeKey1 = `${parent[node]}-${node}`;
                    const edgeKey2 = `${node}-${parent[node]}`;
                    mstEdges.add(edgeKey1);
                    mstEdges.add(edgeKey2);
                    mstTotalWeight += currentMinCost;
                    edgesInMSTCount++;
                }

                drawGraph();
                await new Promise(resolve => setTimeout(resolve, animationSpeed));

                for (const edge of graph[node]) {
                    const neighbor = edge.node;
                    const weight = edge.weight;

                    if (!visitedNodes.has(neighbor) && weight < minCost[neighbor]) {
                        minCost[neighbor] = weight;
                        parent[neighbor] = node;
                        priorityQueue.enqueue(neighbor, weight);
                        drawGraph();
                        await new Promise(resolve => setTimeout(resolve, animationSpeed));
                    }
                }
            }

            currentNode = null;
            drawGraph();
            isAlgorithmRunning = false;
            startButton.disabled = false;
            resetButton.disabled = false;
            speedSlider.disabled = false;
            startNodeSelect.disabled = false;
            targetNodeSelect.disabled = false;
            algorithmSelect.disabled = false;
            modeSelect.disabled = false;
            graphInteractionModeSelect.disabled = false; // Re-enable interaction mode

            let resultMessage = `Minimum Spanning Tree (Prim's) Complete!\nTotal Weight: ${mstTotalWeight}`;
            showModal("MST Complete!", resultMessage);
            console.log("MST Edges:", Array.from(mstEdges));
            console.log("MST Total Weight:", mstTotalWeight);
        }

        // --- Placeholder for Grid Algorithm ---
        async function runGridAlgorithm() {
            showModal("Grid Algorithm", "Grid-based algorithms are coming soon!");
        }

        // Function to reset the current visualization state
        function resetVisualization() {
            // Reset graph-specific states
            visitedNodes = new Set();
            queueNodes = [];
            stackNodes = [];
            currentNode = null;
            visitedOrder = [];
            distances = {};
            previousNodes = {};
            finalizedNodes = new Set();
            pathNodes = [];
            floydDistMatrix = [];
            floydPathMatrix = [];
            currentK = -1; currentI = -1; currentJ = -1;
            distanceMatrixTableDiv.innerHTML = '';
            mstEdges = new Set();
            mstTotalWeight = 0;
            // Reset interaction states
            draggedNode = null;
            startEdgeNode = null;
            mouseX = 0;
            mouseY = 0;


            // Reset grid-specific states
            gridWalls = new Set();
            gridVisited = new Set();
            gridPath = [];
            startGridNode = null;
            endGridNode = null;

            if (currentMode === 'graph') {
                drawGraph();
            } else if (currentMode === 'grid') {
                initializeGrid(); // Re-initialize and draw empty grid
            }
            // Re-enable all controls after reset
            startButton.disabled = false;
            resetButton.disabled = false;
            speedSlider.disabled = false;
            startNodeSelect.disabled = false;
            targetNodeSelect.disabled = false;
            algorithmSelect.disabled = false;
            modeSelect.disabled = false;
            graphInteractionModeSelect.disabled = false;
            customModal.style.display = 'none'; // Hide modal on reset
        }

        // --- Event Listeners ---

        modeSelect.addEventListener('change', (event) => {
            currentMode = event.target.value;
            updateUI();
            resetVisualization(); // Reset when mode changes
        });

        algorithmSelect.addEventListener('change', (event) => {
            currentAlgorithm = event.target.value;
            updateUI();
            resetVisualization(); // Reset when algorithm changes
        });

        graphInteractionModeSelect.addEventListener('change', (event) => {
            currentGraphInteractionMode = event.target.value;
            updateUI(); // Update UI to show/hide edge weight input
            // Reset any ongoing interaction states when mode changes
            draggedNode = null;
            startEdgeNode = null;
            drawGraph(); // Redraw to clear any temporary lines
        });

        startButton.addEventListener('click', () => {
            if (!isAlgorithmRunning) {
                if (currentMode === 'graph') {
                    const selectedStartNode = startNodeSelect.value;
                    const selectedTargetNode = targetNodeSelect.value;
                    switch (currentAlgorithm) {
                        case 'bfs':
                            bfs(selectedStartNode);
                            break;
                        case 'dfs':
                            dfs(selectedStartNode);
                            break;
                        case 'dijkstra':
                            dijkstra(selectedStartNode, selectedTargetNode);
                            break;
                        case 'floyd-warshall':
                            floydWarshall();
                            break;
                        case 'mst':
                            primMST(selectedStartNode);
                            break;
                    }
                } else if (currentMode === 'grid') {
                    runGridAlgorithm(); // Placeholder for grid algorithm start
                }
            }
        });

        resetButton.addEventListener('click', () => {
            resetVisualization();
        });

        speedSlider.addEventListener('input', (event) => {
            animationSpeed = parseInt(event.target.value);
            speedValueSpan.textContent = `${animationSpeed}ms`;
        });

        // Grid specific event listeners
        generateGridButton.addEventListener('click', () => {
            initializeGrid();
            showModal("Grid Generated", "An empty grid has been generated. You can now implement grid algorithms.");
        });

        clearGridButton.addEventListener('click', () => {
            initializeGrid(); // Re-initialize to clear any drawings
            showModal("Grid Cleared", "The grid has been cleared.");
        });

        gridSpeedSlider.addEventListener('input', (event) => {
            animationSpeed = parseInt(event.target.value); // Use same animationSpeed for now
            gridSpeedValueSpan.textContent = `${animationSpeed}ms`;
        });

        // --- Canvas Mouse Event Listeners for Graph Customization ---
        canvas.addEventListener('mousedown', (e) => {
            if (isAlgorithmRunning || currentMode !== 'graph') return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const clickedNode = getNodeAt(x, y);

            if (currentGraphInteractionMode === 'select') {
                if (clickedNode) {
                    draggedNode = clickedNode;
                }
            } else if (currentGraphInteractionMode === 'add-node') {
                if (!clickedNode) { // Only add if not clicking on an existing node
                    addNode(x, y);
                }
            } else if (currentGraphInteractionMode === 'remove-node') {
                if (clickedNode) {
                    removeNode(clickedNode);
                } else {
                    showModal("Error", "Click on a node to remove it.");
                }
            } else if (currentGraphInteractionMode === 'add-edge') {
                if (clickedNode) {
                    if (!startEdgeNode) {
                        startEdgeNode = clickedNode;
                    } else if (startEdgeNode !== clickedNode) {
                        const weight = newEdgeWeightInput.value;
                        addEdge(startEdgeNode, clickedNode, weight);
                        startEdgeNode = null; // Reset for next edge
                    }
                } else {
                    startEdgeNode = null; // Reset if clicked outside a node
                }
                drawGraph(); // Redraw to clear temporary line if interaction resets
            } else if (currentGraphInteractionMode === 'remove-edge') {
                if (clickedNode) {
                    if (!startEdgeNode) {
                        startEdgeNode = clickedNode;
                    } else if (startEdgeNode !== clickedNode) {
                        removeEdge(startEdgeNode, clickedNode);
                        startEdgeNode = null; // Reset for next edge
                    }
                } else {
                    startEdgeNode = null; // Reset if clicked outside a node
                }
                drawGraph(); // Redraw to clear temporary line if interaction resets
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isAlgorithmRunning || currentMode !== 'graph') return;

            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            if (currentGraphInteractionMode === 'select' && draggedNode) {
                nodePositions[draggedNode].x = mouseX;
                nodePositions[draggedNode].y = mouseY;
                drawGraph();
            } else if (currentGraphInteractionMode === 'add-edge' && startEdgeNode) {
                drawGraph(); // Redraw to update temporary line
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isAlgorithmRunning || currentMode !== 'graph') return;
            draggedNode = null; // Stop dragging
            // startEdgeNode is handled in mousedown for add-edge/remove-edge
        });

        // Initialize on load
        window.onload = function() {
            // Set canvas dimensions based on its container, but cap max width
            const containerWidth = canvas.parentElement.clientWidth;
            canvas.width = Math.min(containerWidth * 0.9, 900); // Graph canvas
            canvas.height = 500;

            gridCanvas.width = Math.min(containerWidth * 0.9, 900); // Grid canvas
            gridCanvas.height = 500;

            populateNodeSelects();
            updateUI(); // Initial UI setup
            drawGraph(); // Initial graph draw
            initializeGrid(); // Initial grid draw
        };

        // Handle window resize to make canvas responsive
        window.addEventListener('resize', () => {
            const containerWidth = canvas.parentElement.clientWidth;
            canvas.width = Math.min(containerWidth * 0.9, 900);
            gridCanvas.width = Math.min(containerWidth * 0.9, 900);

            if (currentMode === 'graph') {
                drawGraph(); // Redraw graph to fit new canvas size
            } else if (currentMode === 'grid') {
                cellSize = Math.min(gridCanvas.width / GRID_COLS, gridCanvas.height / GRID_ROWS); // Recalculate cellSize
                drawGrid(); // Redraw grid to fit new canvas size
            }
        });
    </script>
</body>
</html>
